.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Statistics::Basic::LeastSquareFit 3"
.TH Statistics::Basic::LeastSquareFit 3 "2012-01-23" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Statistics::Basic::LeastSquareFit \- find the least square fit for two lists
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
A machine to calculate the Least Square Fit of given vectors x and y.
.PP
The module returns the alpha and beta filling this formula:
.PP
.Vb 1
\&    $y = $beta * $x + $alpha
.Ve
.PP
for a given set of \fIx\fR and \fIy\fR co-ordinate pairs.
.PP
Say you have the set of Cartesian coordinates:
.PP
.Vb 1
\&    my @points = ( [1,1], [2,2], [3,3], [4,4] );
.Ve
.PP
The simplest way to find the \s-1LSF\s0 is as follows:
.PP
.Vb 2
\&    my $lsf = lsf()\->set_size(int @points);
\&       $lsf\->insert(@$_) for @points;
.Ve
.PP
Or this way:
.PP
.Vb 3
\&    my $xv  = vector( map {$_\->[0]} @points );
\&    my $yv  = vector( map {$_\->[1]} @points );
\&    my $lsf = lsf($xv, $yv);
.Ve
.PP
And then either query the values or print them like so:
.PP
.Vb 3
\&    print "The LSF for $xv and $yv: $lsf\en";
\&    my ($yint, $slope) =
\&    my ($alpha, $beta) = $lsf\->query;
.Ve
.PP
\&\s-1LSF\s0 is meant for finding a line of best
fit.  \f(CW$beta\fR is the slope of the line and \f(CW$alpha\fR is the y\-offset.  Suppose
you want to draw the line.  Use these to calculate the \f(CW\*(C`x\*(C'\fR for a given \f(CW\*(C`y\*(C'\fR or
vice versa:
.PP
.Vb 2
\&    my $y = $lsf\->y_given_x( 7 );
\&    my $x = $lsf\->x_given_y( 7 );
.Ve
.PP
(Note that \f(CW\*(C`x_given_y()\*(C'\fR can sometimes produce a divide-by-zero error since it
has to divide by the \f(CW$beta\fR.)
.PP
Create a 20 point \*(L"moving\*(R" \s-1LSF\s0 like so:
.PP
.Vb 1
\&    use Statistics::Basic qw(:all nofill);
\&
\&    my $sth = $dbh\->prepare("select x,y from points where something");
\&    my $len = 20;
\&    my $lsf = lsf()\->set_size($len);
\&
\&    $sth\->execute or die $dbh\->errstr;
\&    $sth\->bind_columns( my ($x, $y) ) or die $dbh\->errstr;
\&
\&    my $count = $len;
\&    while( $sth\->fetch ) {
\&        $lsf\->insert( $x, $y );
\&        if( defined( my ($yint, $slope) = $lsf\->query ) {
\&            print "LSF: y= $slope*x + $yint\en";
\&        }
\&
\&        # This would also work:
\&        # print "$lsf\en" if $lsf\->query_filled;
\&    }
.Ve
.SH "METHODS"
.IX Header "METHODS"
This list of methods skips the methods inherited from
Statistics::Basic::_TwoVectorBase (things like
\&\fIinsert()\fR, and
\&\fIginsert()\fR).
.IP "\fB\f(BInew()\fB\fR" 4
.IX Item "new()"
Create a new Statistics::Basic::LeastSquareFit object.  This function takes
two arguments \*(-- which can either be arrayrefs or Statistics::Basic::Vector
objects.  This function is called when the
\&\fIleastsquarefirt()\fR
shortcut-function is called.
.IP "\fB\f(BIquery()\fB\fR" 4
.IX Item "query()"
\&\s-1LSF\s0 is meant for finding a line of best
fit.  \f(CW$beta\fR is the slope of the line and \f(CW$alpha\fR is the y\-offset.
.Sp
.Vb 1
\&    my ($alpha, $beta) = $lsf\->query;
.Ve
.IP "\fB\f(BIy_given_x()\fB\fR" 4
.IX Item "y_given_x()"
Automatically calculate the y\-value on the line for a given x\-value.
.Sp
.Vb 1
\&    my $y = $lsf\->y_given_x( 7 );
.Ve
.IP "\fB\f(BIx_given_y()\fB\fR" 4
.IX Item "x_given_y()"
Automatically calculate the x\-value on the line for a given y\-value.
.Sp
.Vb 1
\&    my $x = $lsf\->x_given_y( 7 );
.Ve
.Sp
\&\f(CW\*(C`x_given_y()\*(C'\fR can sometimes produce a divide-by-zero error since it
has to divide by the \f(CW$beta\fR.  This might be helpful:
.Sp
.Vb 2
\&    if( defined( my $x = eval { $lsf\->x_given_y(7) } ) ) {
\&        warn "there is no x value for 7";
\&
\&    } else {
\&        print "x (given y=7): $x\en";
\&    }
.Ve
.IP "\fB\f(BIquery_vector1()\fB\fR" 4
.IX Item "query_vector1()"
Return the Statistics::Basic::Vector for the first vector used in the
computation of alpha and beta.
.IP "\fB\f(BIquery_vector2()\fB\fR" 4
.IX Item "query_vector2()"
Return the Statistics::Basic::Vector object for the second vector used in the
computation of alpha and beta.
.IP "\fB\f(BIquery_mean1()\fB\fR" 4
.IX Item "query_mean1()"
Returns the Statistics::Basic::Mean object for the first vector used in the
computation of alpha and beta.
.IP "\fB\f(BIquery_variance1()\fB\fR" 4
.IX Item "query_variance1()"
Returns the Statistics::Basic::Variance object for the first vector used in
the computation of alpha and beta.
.IP "\fB\f(BIquery_covariance()\fB\fR" 4
.IX Item "query_covariance()"
Returns the Statistics::Basic::Covariance object used in the computation of
alpha and beta.
.SH "OVERLOADS"
.IX Header "OVERLOADS"
This object is overloaded.  It tries to return an appropriate string for the
calculation, but raises an error in numeric context.
.PP
In boolean context, this object is always true (even when empty).
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Miller \f(CW\*(C`<jettero@cpan.org>\*(C'\fR
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2012 Paul Miller \*(-- Licensed under the \s-1LGPL\s0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), Statistics::Basic, Statistics::Basic::_TwoVectorBase, Statistics::Basic::Vector
