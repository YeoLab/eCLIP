.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Regexp::Common 3"
.TH Regexp::Common 3 "2001-01-29" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Regexp::Common \- Provide commonly requested regular expressions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& # STANDARD USAGE 
\&
\& use Regexp::Common;
\&
\& while (<>) {
\&        /$RE{num}{real}/                and print q{a number\en};
\&        /$RE{quoted}                    and print q{a [\*(Aq"\`] quoted string\en};
\&        /$RE{delimited}{\-delim=>\*(Aq/\*(Aq}/   and print q{a /.../ sequence\en};
\&        /$RE{balanced}{\-parens=>\*(Aq()\*(Aq}/  and print q{balanced parentheses\en};
\&        /$RE{profanity}/                and print q{a #*@%\-ing word\en};
\& }
\&
\&
\& # SUBROUTINE\-BASED INTERFACE
\&
\& use Regexp::Common \*(AqRE\*(Aq;
\&
\& while (<>) {
\&        $_ =~ RE_num_real()              and print q{a number\en};
\&        $_ =~ RE_quoted()                and print q{a [\*(Aq"\`] quoted string\en};
\&        $_ =~ RE_delimited(\-delim=>\*(Aq/\*(Aq)  and print q{a /.../ sequence\en};
\&        $_ =~ RE_balanced(\-parens=>\*(Aq()\*(Aq} and print q{balanced parentheses\en};
\&        $_ =~ RE_profanity()             and print q{a #*@%\-ing word\en};
\& }
\&
\&
\& # IN\-LINE MATCHING...
\&
\& if ( $RE{num}{int}\->matches($text} ) {...}
\&
\&
\& # ...AND SUBSTITUTION
\&
\& my $cropped = $RE{ws}{crop}\->subs($uncropped);
\&
\&
\& # ROLL\-YOUR\-OWN PATTERNS
\&
\& use Regexp::Common \*(Aqpattern\*(Aq;
\&
\& pattern name   => [\*(Aqname\*(Aq, \*(Aqmine\*(Aq],
\&         create => \*(Aq(?i:J[.]?\es+A[.]?\es+Perl\-Hacker)\*(Aq,
\&         ;
\&
\& my $name_matcher = $RE{name}{mine};
\&
\& pattern name    => [ \*(Aqlineof\*(Aq, \*(Aq\-char=_\*(Aq ],
\&         create  => sub {
\&                        my $flags = shift;
\&                        my $char = quotemeta $flags\->{\-char};
\&                        return \*(Aq(?:^$char+$)\*(Aq;
\&                    },
\&         matches => sub {
\&                        my ($self, $str) = @_;
\&                        return $str !~ /[^$self\->{flags}{\-char}]/;
\&                    },
\&         subs   => sub {
\&                        my ($self, $str, $replacement) = @_;
\&                        $_[1] =~ s/^$self\->{flags}{\-char}+$//g;
\&                   },
\&         ;
\&
\& my $asterisks = $RE{lineof}{\-char=>\*(Aq*\*(Aq};
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
By default, this module exports a single hash (\f(CW%RE\fR) that stores or generates
commonly needed regular expressions (see \*(L"List of available patterns\*(R").
.PP
There is an alternative, subroutine-based syntax described in
\&\*(L"Subroutine-based interface\*(R".
.SS "General syntax for requesting patterns"
.IX Subsection "General syntax for requesting patterns"
To access a particular pattern, \f(CW%RE\fR is treated as a hierarchical hash of
hashes (of hashes...), with each successive key being an identifier. For
example, to access the pattern that matches real numbers, you 
specify:
.PP
.Vb 1
\&        $RE{num}{real}
.Ve
.PP
and to access the pattern that matches integers:
.PP
.Vb 1
\&        $RE{num}{int}
.Ve
.PP
Deeper layers of the hash are used to specify \fIflags\fR: arguments that
modify the resulting pattern in some way. The keys used to access these
layers are prefixed with a minus sign and may include a value that is
introduced by an equality sign. For example, to access the pattern that
matches base\-2 real numbers with embedded commas separating
groups of three digits (e.g. 10,101,110.110101101):
.PP
.Vb 1
\&        $RE{num}{real}{\*(Aq\-base=2\*(Aq}{\*(Aq\-sep=,\*(Aq}{\*(Aq\-group=3\*(Aq}
.Ve
.PP
Through the magic of Perl, these flag layers may be specified in any order
(and even interspersed through the identifier keys!)
so you could get the same pattern with:
.PP
.Vb 1
\&        $RE{num}{real}{\*(Aq\-sep=,\*(Aq}{\*(Aq\-group=3\*(Aq}{\*(Aq\-base=2\*(Aq}
.Ve
.PP
or:
.PP
.Vb 1
\&        $RE{num}{\*(Aq\-base=2\*(Aq}{real}{\*(Aq\-group=3\*(Aq}{\*(Aq\-sep=,\*(Aq}
.Ve
.PP
or even:
.PP
.Vb 1
\&        $RE{\*(Aq\-base=2\*(Aq}{\*(Aq\-group=3\*(Aq}{\*(Aq\-sep=,\*(Aq}{num}{real}
.Ve
.PP
etc.
.PP
Note, however, that the relative order of amongst the identifier keys
\&\fIis\fR significant. That is:
.PP
.Vb 1
\&        $RE{list}{set}
.Ve
.PP
would not be the same as:
.PP
.Vb 1
\&        $RE{set}{list}
.Ve
.SS "Alternative flag syntax"
.IX Subsection "Alternative flag syntax"
As the examples in the previous section indicate, the syntax for
specifying flags is somewhat cumbersome, because of the need to quote
the entire (non-identifier) key-plus-value. To make such specifications
less ugly, Regexp::Common permanently changes the value of the magical
\&\f(CW$;\fR variable (setting it to the character \f(CW\*(Aq=\*(Aq\fR), so that flags can
also be specified like so:
.PP
.Vb 1
\&        $RE{num}{real}{\-base=>2}{\-group=>3}{\-sep=>\*(Aq,\*(Aq}
.Ve
.PP
This syntax is preferred, and is used throughout the rest of this document.
.PP
In the unlikely case that the non-standard value of \f(CW$;\fR breaks your
program, this behaviour can be disabled by importing the module as:
.PP
.Vb 1
\&        use Regexp::Common \*(Aqclean\*(Aq;
.Ve
.SS "Universal flags"
.IX Subsection "Universal flags"
Normally, flags are specific to a single pattern.
However, there is one flag that all patterns may specify.
.PP
By default, the patterns provided by \f(CW%RE\fR contain no capturing
parentheses. However, if the \f(CW\*(C`\-keep\*(C'\fR flag is specified (it requires
no value) then any significant substrings that the pattern matches
are captured. For example:
.PP
.Vb 5
\&        if ($str =~ $RE{num}{real}{\-keep}) {
\&                $number   = $1;
\&                $whole    = $3;
\&                $decimals = $5;
\&        }
.Ve
.PP
Special care is needed if a \*(L"kept\*(R" pattern is interpolated into a
larger regular expression, as the presence of other capturing
parentheses is likely to change the \*(L"number variables\*(R" into which significant
substrings are saved.
.PP
See also \*(L"Adding new regular expressions\*(R", which describes how to create
new patterns with \*(L"optional\*(R" capturing brackets that respond to \f(CW\*(C`\-keep\*(C'\fR.
.SS "\s-1OO\s0 interface and inline matching/substitution"
.IX Subsection "OO interface and inline matching/substitution"
The patterns returned from \f(CW%RE\fR are objects, so rather than writing:
.PP
.Vb 1
\&        if ($str =~ /$RE{some}{pattern}/ ) {...}
.Ve
.PP
you can write:
.PP
.Vb 1
\&        if ( $RE{some}{pattern}\->matches($str) ) {...}
.Ve
.PP
For matching this would seem to have no great advantage apart from readability
(but see below).
.PP
For substitutions, it has other significant benefits. Frequently you want to
perform a substitution on a string without changing the original. Most people
use this:
.PP
.Vb 2
\&        $changed = $original;
\&        $changed =~ s/$RE{some}{pattern}/$replacement/;
.Ve
.PP
The more adept use:
.PP
.Vb 1
\&        ($changed = $original) =~ s/$RE{some}{pattern}/$replacement/;
.Ve
.PP
Regexp::Common allows you do write this:
.PP
.Vb 1
\&        $changed = $RE{some}{pattern}\->subs($original=>$replacement);
.Ve
.PP
Apart from reducing precedence-angst, this approach has the daded
advantages that the substitution behaviour can be optimized fro the 
regular expression, and the replacement string can be provided by
default (see \*(L"Adding new regular expressions\*(R").
.PP
For example, in the implementation of this substitution:
.PP
.Vb 1
\&        $cropped = $RE{ws}{crop}\->subs($uncropped);
.Ve
.PP
the default empty string is provided automatically, and the substitution is
optimized to use:
.PP
.Vb 2
\&        $uncropped =~ s/^\es+//;
\&        $uncropped =~ s/\es+$//;
.Ve
.PP
rather than:
.PP
.Vb 1
\&        $uncropped =~ s/^\es+|\es+$//g;
.Ve
.SS "Subroutine-based interface"
.IX Subsection "Subroutine-based interface"
The hash-based interface was chosen because it allows regexes to be
effortlessly interpolated, and because it also allows them to be
\&\*(L"curried\*(R". For example:
.PP
.Vb 1
\&        my $num = $RE{num}{int};
\&
\&        my $comma\*(Aqd    = $num\->{\-sep=>\*(Aq,\*(Aq}{\-group=>3};
\&        my $duodecimal = $num\->{\-base=>12};
.Ve
.PP
However, the use of tied hashes does make the access to Regexp::Common
patterns slower than it might otherwise be. In contexts where impatience
overrules laziness, Regexp::Common provides an additional
subroutine-based interface.
.PP
For each (sub\-)entry in the \f(CW%RE\fR hash (\f(CW$RE{key1}{key2}{etc}\fR), there
is a corresponding exportable subroutine: \f(CW\*(C`RE_key1_key2_etc()\*(C'\fR. The name of
each subroutine is the underscore-separated concatenation of the \fInon-flag\fR
keys that locate the same pattern in \f(CW%RE\fR. Flags are passed to the subroutine
in its argument list. Thus:
.PP
.Vb 1
\&        use Regexp::Common qw( RE_ws_crop RE_num_real RE_profanity );
\&
\&        $str =~ RE_ws_crop() and die "Surrounded by whitespace";
\&
\&        $str =~ RE_num_real(\-base=>8, \-sep=>" ") or next;
\&
\&        $offensive = RE_profanity(\-keep);
\&        $str =~ s/$offensive/$bad{$1}++; "<expletive deleted>"/ge;
.Ve
.PP
Note that, unlike the hash-based interface (which returns objects), these
subroutines return ordinary \f(CW\*(C`qr\*(C'\fR'd regular expressions. Hence they do not
curry, nor do they provide the \s-1OO\s0 match and substitution inlining described
in the previous section.
.PP
It is also possible to export subroutines for all available patterns like so:
.PP
.Vb 1
\&        use Regexp::Common \*(AqRE_ALL\*(Aq;
.Ve
.SS "Adding new regular expressions"
.IX Subsection "Adding new regular expressions"
You can add your own regular expressions to the \f(CW%RE\fR hash at run-time,
using the exportable \f(CW\*(C`pattern\*(C'\fR subroutine. It expects a hash-like list of 
key/value pairs that specify the behaviour of the pattern. The various
possible argument pairs are:
.ie n .IP """name => [ @list ]""" 4
.el .IP "\f(CWname => [ @list ]\fR" 4
.IX Item "name => [ @list ]"
A required argument that specifies the name of the pattern, and any
flags it may take, via a reference to a list of strings. For example:
.Sp
.Vb 3
\&         pattern name => [qw( line of \-char )],
\&                 # other args here
\&                 ;
.Ve
.Sp
This specifies an entry \f(CW$RE{line}{of}\fR, which may take a \f(CW\*(C`\-char\*(C'\fR flag.
.Sp
Flags may also be specified with a default value, which is then used whenever
the flag is omitted, or specified without an explicit value. For example:
.Sp
.Vb 4
\&         pattern name => [qw( line of \-char=_ )],
\&                 # default char is \*(Aq_\*(Aq
\&                 # other args here
\&                 ;
.Ve
.ie n .IP """create => $sub_ref_or_string""" 4
.el .IP "\f(CWcreate => $sub_ref_or_string\fR" 4
.IX Item "create => $sub_ref_or_string"
A required argument that specifies either a string that is to be returned
as the pattern:
.Sp
.Vb 3
\&        pattern name    => [qw( line of underscores )],
\&                create  => q/(?:^_+$)/
\&                ;
.Ve
.Sp
or a reference to a subroutine that will be called to create the pattern:
.Sp
.Vb 7
\&        pattern name    => [qw( line of \-char=_ )],
\&                create  => sub {
\&                                my ($self, $flags) = @_;
\&                                my $char = quotemeta $flags\->{\-char};
\&                                return \*(Aq(?:^$char+$)\*(Aq;
\&                            },
\&                ;
.Ve
.Sp
If the subroutine version is used, the subroutine will be called with 
three arguments: a reference to the pattern object itself, a reference
to a hash containing the flags and their values,
and a reference to an array containing the non-flag keys.
.Sp
Whatever the subroutine returns is stringified as the pattern.
.Sp
No matter how the pattern is created, it is immediately postprocessed to
include or exclude capturing parentheses (according to the value of the
\&\f(CW\*(C`\-keep\*(C'\fR flag). To specify such \*(L"optional\*(R" capturing parentheses within
the regular expression associated with \f(CW\*(C`create\*(C'\fR, use the notation
\&\f(CW\*(C`(?k:...)\*(C'\fR. Any parentheses of this type will be converted to \f(CW\*(C`(...)\*(C'\fR
when the \f(CW\*(C`\-keep\*(C'\fR flag is specified, or \f(CW\*(C`(?:...)\*(C'\fR when it is not.
It is a Regexp::Common convention that the outermost capturing parentheses
always capture the entire pattern, but this is not enforced.
.ie n .IP """matches => $sub_ref""" 4
.el .IP "\f(CWmatches => $sub_ref\fR" 4
.IX Item "matches => $sub_ref"
An optional argument that specifies a subroutine that is to be called when
the \f(CW\*(C`$RE{...}\->matches(...)\*(C'\fR method of this pattern is invoked.
.Sp
The subroutine should expect two arguments: a reference to the pattern object
itself, and the string to be matched against.
.Sp
It should return the same types of values as a \f(CW\*(C`m/.../\*(C'\fR does.
.Sp
.Vb 7
\&        pattern name    => [qw( line of \-char )],
\&                create  => sub {...},
\&                matches => sub {
\&                                my ($self, $str) = @_;
\&                                return $str !~ /[^$self\->{flags}{\-char}]/;
\&                           },
\&                ;
.Ve
.ie n .IP """subs => $sub_ref""" 4
.el .IP "\f(CWsubs => $sub_ref\fR" 4
.IX Item "subs => $sub_ref"
An optional argument that specifies a subroutine that is to be called when
the \f(CW\*(C`$RE{...}\->subs(...)\*(C'\fR method of this pattern is invoked.
.Sp
The subroutine should expect three arguments: a reference to the pattern object
itself, the string to be changed, and the value to be substituted into it.
The third argument may be \f(CW\*(C`undef\*(C'\fR, indicating the default substitution is
required.
.Sp
The subroutine should return the same types of values as an \f(CW\*(C`s/.../.../\*(C'\fR does.
.Sp
For example:
.Sp
.Vb 7
\&        pattern name    => [ \*(Aqlineof\*(Aq, \*(Aq\-char=_\*(Aq ],
\&                create  => sub {...},
\&                subs   => sub {
\&                                my ($self, $str, $ignore_replacement) = @_;
\&                                $_[1] =~ s/^$self\->{flags}{\-char}+$//g;
\&                          },
\&                 ;
.Ve
.Sp
Note that such a subroutine will almost always need to modify \f(CW$_[1]\fR directly.
.ie n .IP """version => $minimum_perl_version""" 4
.el .IP "\f(CWversion => $minimum_perl_version\fR" 4
.IX Item "version => $minimum_perl_version"
If this argument is given, it specifies the minimum version of perl required
to use the new pattern. Attempts to use the pattern with earlier versions of
perl will generate a fatal diagnostic.
.SS "List of available patterns"
.IX Subsection "List of available patterns"
The following patterns are currently available:
.Sp
.RS 4
\&\f(CW$RE{balanced}{\-parens}\fR
.Sp
Returns a pattern that matches a string that starts with the nominated
opening parenthesis or bracket, contains characters and properly nested
parenthesized subsequences, and ends in the matching parenthesis.
.Sp
More than one type of parenthesis can be specified:
.Sp
.Vb 1
\&        $RE{balanced}{\-parens=>\*(Aq(){}\*(Aq}
.Ve
.Sp
in which case all specified parenthesis types must be correctly balanced within
the string.
.Sp
Under \f(CW\*(C`\-keep\*(C'\fR:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
captures the entire expression
.RE
.RS 4
.Sp
\&\f(CW$RE{num}{int}{\-sep}{\-group}\fR
.Sp
Returns a pattern that matches a decimal integer.
.Sp
If \f(CW\*(C`\-sep=\f(CIP\f(CW\*(C'\fR is specified, the pattern \fIP\fR is required as a grouping marker
within the number.
.Sp
If \f(CW\*(C`\-group=\f(CIN\f(CW\*(C'\fR is specified, digits between grouping markers must be
grouped in sequences of exactly \fIN\fR characters. The default value of \fIN\fR is 3.
.Sp
For example:
.Sp
.Vb 4
\&        $RE{num}{int}                            # match 1234567
\&        $RE{num}{int}{\-sep=>\*(Aq,\*(Aq}                 # match 1,234,567
\&        $RE{num}{int}{\-sep=>\*(Aq,?\*(Aq}                # match 1234567 or 1,234,567
\&        $RE{num}{int}{\-sep=>\*(Aq.\*(Aq}{\-group=>4}      # match 1.2345.6789
.Ve
.Sp
Under \f(CW\*(C`\-keep\*(C'\fR:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
captures the entire number
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
captures the optional sign number
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
captures the complete set of digits
.RE
.RS 4
.Sp
\&\f(CW$RE{num}{real}{\-base}{\-radix}{\-places}{\-sep}{\-group}{\-expon}\fR
.Sp
Returns a pattern that matches a floating-point number.
.Sp
If \f(CW\*(C`\-base=\f(CIN\f(CW\*(C'\fR is specified, the number is assumed to be in that base
(with A..Z representing the digits for 11..36). By default, the base is 10.
.Sp
If \f(CW\*(C`\-radix=\f(CIP\f(CW\*(C'\fR is specified, the pattern \fIP\fR is used as the radix point for
the number (i.e. the \*(L"decimal point\*(R" in base 10). The default is \f(CW\*(C`qr/[.]/\*(C'\fR.
.Sp
If \f(CW\*(C`\-places=\f(CIN\f(CW\*(C'\fR is specified, the number is assumed to have exactly
\&\fIN\fR places after the radix point.
If \f(CW\*(C`\-places=\f(CIM,N\f(CW\*(C'\fR is specified, the number is assumed to have between
\&\fIM\fR and \fIN\fR places after the radix point.
By default, the number of places is unrestricted.
.Sp
If \f(CW\*(C`\-sep=\f(CIP\f(CW\*(C'\fR specified, the pattern \fIP\fR is required as a grouping marker
within the pre-radix section of the number. By default, no separator is
allowed.
.Sp
If \f(CW\*(C`\-group=\f(CIN\f(CW\*(C'\fR is specified, digits between grouping separators
must be grouped in sequences of exactly \fIN\fR characters. The default value of
\&\fIN\fR is 3.
.Sp
If \f(CW\*(C`\-expon=\f(CIP\f(CW\*(C'\fR is specified, the pattern \fIP\fR is used as the exponential
marker.  The default value of \fIP\fR is \f(CW\*(C`qr/[Ee]/.\*(C'\fR
.Sp
For example:
.Sp
.Vb 5
\&        $RE{num}{real}                  # matches 123.456 or \-0.1234567
\&        $RE{num}{real}{\-places=2}       # matches 123.45 or \-0.12
\&        $RE{num}{real}{\-places=\*(Aq0,3\*(Aq}   # matches 123.456 or 0 or 9.8
\&        $RE{num}{real}{\-sep=>\*(Aq[,.]?\*(Aq}   # matches 123,456 or 123.456
\&        $RE{num}{real}{\-base=>3\*(Aq}       # matches 121.102
.Ve
.Sp
Under \f(CW\*(C`\-keep\*(C'\fR:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
captures the entire match
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
captures the optional sign
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
captures the complete mantissa
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
captures the whole number portion of the mantissa
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
captures the radix point
.ie n .IP "$6" 4
.el .IP "\f(CW$6\fR" 4
.IX Item "$6"
captures the fractional portion of the mantissa
.ie n .IP "$7" 4
.el .IP "\f(CW$7\fR" 4
.IX Item "$7"
captures the optional exponent marker
.ie n .IP "$8" 4
.el .IP "\f(CW$8\fR" 4
.IX Item "$8"
captures the entire exponent value
.ie n .IP "$9" 4
.el .IP "\f(CW$9\fR" 4
.IX Item "$9"
captures the optional sign of the exponent
.ie n .IP "$10" 4
.el .IP "\f(CW$10\fR" 4
.IX Item "$10"
captures the digits of the exponent
.RE
.RS 4
.Sp
\&\f(CW$RE{num}{dec}{\-radix}{\-places}{\-sep}{\-group}{\-expon}\fR
.Sp
A synonym for \f(CW\*(C`$RE{num}{real}{\-base=\*(C'\fR10}{...}>
.Sp
\&\f(CW$RE{num}{oct}{\-radix}{\-places}{\-sep}{\-group}{\-expon}\fR
.Sp
A synonym for \f(CW\*(C`$RE{num}{real}{\-base=\*(C'\fR8}{...}>
.Sp
\&\f(CW$RE{num}{bin}{\-radix}{\-places}{\-sep}{\-group}{\-expon}\fR
.Sp
A synonym for \f(CW\*(C`$RE{num}{real}{\-base=\*(C'\fR2}{...}>
.Sp
\&\f(CW$RE{num}{hex}{\-radix}{\-places}{\-sep}{\-group}{\-expon}\fR
.Sp
A synonym for \f(CW\*(C`$RE{num}{real}{\-base=\*(C'\fR16}{...}>
.Sp
\&\f(CW$RE{comment}{\f(CIlanguage\f(CW}\fR
.Sp
A comment string in the nominated language.
.Sp
Available languages are:
.Sp
.Vb 4
\&        $RE{comment}{C}
\&        $RE{comment}{C++}
\&        $RE{comment}{shell}
\&        $RE{comment}{Perl}
.Ve
.Sp
Under \f(CW\*(C`\-keep\*(C'\fR:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
captures the entire match
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
captures the opening comment marker (except for \f(CW$RE{comment}{C++}\fR)
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
captures the contents of the comment (except for \f(CW$RE{comment}{C++}\fR)
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
captures the  closing comment marker (except for \f(CW$RE{comment}{C++}\fR)
.RE
.RS 4
.Sp
\&\f(CW$RE\fR{profanity}
.Sp
Returns a pattern matching words \*(-- such as Carlin's \*(L"big seven\*(R" \*(-- that
are most likely to give offense. Note that correct anatomical terms are
deliberately \fInot\fR included in the list.
.Sp
Under \f(CW\*(C`\-keep\*(C'\fR:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
captures the entire word
.RE
.RS 4
.Sp
\&\f(CW$RE{profanity}{contextual}\fR
.Sp
Returns a pattern matching words that are likely to give offense when
used in specific contexts, but which also have genuinely
non-offensive meanings.
.Sp
Under \f(CW\*(C`\-keep\*(C'\fR:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
captures the entire word
.RE
.RS 4
.Sp
\&\f(CW$RE{ws}{crop}\fR
.Sp
Returns a pattern that identifies leading or trailing whitespace.
.Sp
For example:
.Sp
.Vb 1
\&        $str =~ s/$RE{ws}{crop}//g;     # Delete surrounding whitespace
.Ve
.Sp
The call:
.Sp
.Vb 1
\&        $RE{ws}{crop}\->subs($str);
.Ve
.Sp
is optimized (but probably still slower than doing the s///g explicitly).
.Sp
This pattern does not capture under \f(CW\*(C`\-keep\*(C'\fR.
.Sp
\&\f(CW$RE{delimited}{\-delim}{\-esc}\fR
.Sp
Returns a pattern that matches a single-character-delimited substring,
with optional internal escaping of the delimiter.
.Sp
When \f(CW\*(C`\-delim=\f(CIS\f(CW\*(C'\fR is specified, each character in the sequence \fIS\fR is
a possible delimiter. There is no default delimiter, so this flag must always
be specified.
.Sp
If \f(CW\*(C`\-esc=\f(CIS\f(CW\*(C'\fR is specified, each character in the sequence \fIS\fR is
the delimiter for the corresponding character in the \f(CW\*(C`\-delim=\f(CIS\f(CW\*(C'\fR list.
The default escape is backslash.
.Sp
For example:
.Sp
.Vb 4
\&        $RE{delimited}{\-delim=>\*(Aq"\*(Aq}             # match "a \e" delimited string"
\&        $RE{delimited}{\-delim=>\*(Aq"\*(Aq}{\-esc=>\*(Aq"\*(Aq}  # match "a "" delimited string"
\&        $RE{delimited}{\-delim=>\*(Aq/\*(Aq}             # match /a \e/ delimited string/
\&        $RE{delimited}{\-delim=>q{\*(Aq"}}           # match "string" or \*(Aqstring\*(Aq
.Ve
.Sp
Under \f(CW\*(C`\-keep\*(C'\fR:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
captures the entire match
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
captures the opening delimiter (provided only one delimiter was specified)
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
captures delimited portion of the string (provided only one delimiter was
specified)
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
captures the closing delimiter (provided only one delimiter was specified)
.RE
.RS 4
.Sp
\&\f(CW$RE\fR{quoted}{\-esc}
.Sp
A synonym for \f(CW$RE{delimited}{q{\-delim=\*(Aq"\`}{...}}\fR
.Sp
\&\f(CW$RE{list}{\-pat}{\-sep}{\-lastsep}\fR
.Sp
Returns a pattern matching a list of (at least two) substrings.
.Sp
If \f(CW\*(C`\-pat=\f(CIP\f(CW\*(C'\fR is specified, it defines the pattern for each substring
in the list. By default, \fIP\fR is \f(CW\*(C`qr/.*?/\*(C'\fR.
.Sp
If \f(CW\*(C`\-sep=\f(CIP\f(CW\*(C'\fR is specified, it defines the pattern \fIP\fR to be used as
a separator between each pair of substrings in the list, except the final two.
By default \fIP\fR is \f(CW\*(C`qr/\es*,\es*/\*(C'\fR.
.Sp
If \f(CW\*(C`\-lastsep=\f(CIP\f(CW\*(C'\fR is specified, it defines the pattern \fIP\fR to be used as
a separator between the final two substrings in the list.
By default \fIP\fR is the same as the pattern specified by the \f(CW\*(C`\-sep\*(C'\fR flag.
.Sp
For example:
.Sp
.Vb 4
\&        $RE{list}{\-pat=>\*(Aq\ew+\*(Aq}                # match a list of word chars
\&        $RE{list}{\-pat=>$RE{num}{real}}       # match a list of numbers
\&        $RE{list}{\-sep=>"\et"}                 # match a tab\-separated list
\&        $RE{list}{\-lastsep=>\*(Aq,\es+and\es+\*(Aq}     # match a proper English list
.Ve
.Sp
Under \f(CW\*(C`\-keep\*(C'\fR:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
captures the entire list
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
captures the last separator
.RE
.RS 4
.Sp
\&\f(CW$RE{list}{conj}{\-word=\f(CIPATTERN\f(CW}\fR
.Sp
An alias for \f(CW\*(C`$RE{list}{\-lastsep=\*(C'\fR'\es*,?\es*\fI\s-1PATTERN\s0\fR\es*'}>
.Sp
If \f(CW\*(C`\-word\*(C'\fR is not specified, the default pattern is \f(CW\*(C`qr/and|or/\*(C'\fR.
.Sp
For example:
.Sp
.Vb 2
\&        $RE{list}{conj}{\-word=>\*(Aqet\*(Aq}             # match Jean, Paul, et Satre
\&        $RE{list}{conj}{\-word=>\*(Aqoder\*(Aq}           # match Bonn, Koln oder Hamburg
.Ve
.Sp
\&\f(CW$RE{list}{and}\fR
.Sp
An alias for \f(CW\*(C`$RE{list}{conj}{\-word=\*(C'\fR'and'}>
.Sp
\&\f(CW$RE{list}{or}\fR
.Sp
An alias for \f(CW\*(C`$RE{list}{conj}{\-word=\*(C'\fR'or'}>
.Sp
\&\f(CW$RE{net}{IPv4}\fR
.Sp
Returns a pattern that matches a valid \s-1IP\s0 address in \*(L"dotted decimal\*(R"
.Sp
For this pattern and the next four, under \f(CW\*(C`\-keep\*(C'\fR:
.ie n .IP "$1" 4
.el .IP "\f(CW$1\fR" 4
.IX Item "$1"
captures the entire match
.ie n .IP "$2" 4
.el .IP "\f(CW$2\fR" 4
.IX Item "$2"
captures the first component of the address
.ie n .IP "$3" 4
.el .IP "\f(CW$3\fR" 4
.IX Item "$3"
captures the second component of the address
.ie n .IP "$4" 4
.el .IP "\f(CW$4\fR" 4
.IX Item "$4"
captures the third component of the address
.ie n .IP "$5" 4
.el .IP "\f(CW$5\fR" 4
.IX Item "$5"
captures the final component of the address
.RE
.RS 4
.Sp
\&\f(CW$RE{net}{IPv4}{dec}{\-sep}\fR
.Sp
Returns a pattern that matches a valid \s-1IP\s0 address in \*(L"dotted decimal\*(R"
.Sp
If \f(CW\*(C`\-sep=\f(CIP\f(CW\*(C'\fR is specified the pattern \fIP\fR is used as the separator.
By default \fIP\fR is \f(CW\*(C`qr/[.]/\*(C'\fR.
.Sp
\&\f(CW$RE{net}{IPv4}{hex}{\-sep}\fR
.Sp
Returns a pattern that matches a valid \s-1IP\s0 address in \*(L"dotted hexadecimal\*(R"
.Sp
If \f(CW\*(C`\-sep=\f(CIP\f(CW\*(C'\fR is specified the pattern \fIP\fR is used as the separator.
By default \fIP\fR is \f(CW\*(C`qr/[.]/\*(C'\fR. \f(CW\*(C`\-sep=\*(C'\fR""> and
\&\f(CW\*(C`\-sep=\*(C'\fR\*(L" \*(R"> are useful alternatives.
.Sp
\&\f(CW$RE{net}{IPv4}{oct}{\-sep}\fR
.Sp
Returns a pattern that matches a valid \s-1IP\s0 address in \*(L"dotted octal\*(R"
.Sp
If \f(CW\*(C`\-sep=\f(CIP\f(CW\*(C'\fR is specified the pattern \fIP\fR is used as the separator.
By default \fIP\fR is \f(CW\*(C`qr/[.]/\*(C'\fR.
.Sp
\&\f(CW$RE{net}{IPv4}{bin}{\-sep}\fR
.Sp
Returns a pattern that matches a valid \s-1IP\s0 address in \*(L"dotted binary\*(R"
.Sp
If \f(CW\*(C`\-sep=\f(CIP\f(CW\*(C'\fR is specified the pattern \fIP\fR is used as the separator.
By default \fIP\fR is \f(CW\*(C`qr/[.]/\*(C'\fR.
.RE
.SS "Forthcoming patterns and features"
.IX Subsection "Forthcoming patterns and features"
Future releases of the module will also provide patterns for the following:
.PP
.Vb 9
\&        * email addresses 
\&        * HTML/XML tags
\&        * more numerical matchers,
\&        * mail headers (including multiline ones),
\&        * URLS (various genres)
\&        * telephone numbers of various countries
\&        * currency (universal 3 letter format, Latin\-1, currency names)
\&        * dates
\&        * binary formats (e.g. UUencoded, MIMEd)
.Ve
.PP
If you have other patterns or pattern generators that you think would be
generally useful, please send them to the author \*(-- preferably as source
code using the \f(CW\*(C`pattern\*(C'\fR subroutine. Submissions that include a set of
tests, will be especially welcome.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP """Can\*(Aqt export unknown subroutine %s""" 4
.el .IP "\f(CWCan\*(Aqt export unknown subroutine %s\fR" 4
.IX Item "Cant export unknown subroutine %s"
The subroutine-based interface didn't recognize the requested subroutine.
Often caused by a spelling mistake or an incompletely specified name.
.ie n .IP """Can\*(Aqt create unknown regex: $RE{...}""" 4
.el .IP "\f(CWCan\*(Aqt create unknown regex: $RE{...}\fR" 4
.IX Item "Cant create unknown regex: $RE{...}"
Regexp::Common doesn't have a generator for the requested pattern.
Often indicates a mispelt or missing parameter.
.ie n .IP " ""Perl %f does not support the pattern $RE{...}. You need Perl %f or later""" 4
.el .IP " \f(CWPerl %f does not support the pattern $RE{...}. You need Perl %f or later\fR" 4
.IX Item " Perl %f does not support the pattern $RE{...}. You need Perl %f or later"
The requested pattern requires advanced regex features (e.g. recursion)
that not available in your version of Perl. Time to upgrade.
.ie n .IP """pattern() requires argument: name ="" [ @list ]>" 4
.el .IP "\f(CWpattern() requires argument: name =\fR [ \f(CW@list\fR ]>" 4
.IX Item "pattern() requires argument: name = [ @list ]>"
Every user-defined pattern specification must have a name.
.ie n .IP """pattern() requires argument: create ="" $sub_ref_or_string>" 4
.el .IP "\f(CWpattern() requires argument: create =\fR \f(CW$sub_ref_or_string\fR>" 4
.IX Item "pattern() requires argument: create = $sub_ref_or_string>"
Every user-defined pattern specification must provide a pattern creation
mechanism: either a pattern string or a reference to a subroutine that
returns the pattern string.
.ie n .IP """Base must be between 1 and 36""" 4
.el .IP "\f(CWBase must be between 1 and 36\fR" 4
.IX Item "Base must be between 1 and 36"
The \f(CW\*(C`$RE{num}{real}{\-base=\*(C'\fR'\fIN\fR'}> pattern uses the characters [0\-9A\-Z]
to represent the digits of various bases. Hence it only produces
regular expressions for bases up to hexatricensimal.
.ie n .IP """Must specify delimiter in $RE{delimited}""" 4
.el .IP "\f(CWMust specify delimiter in $RE{delimited}\fR" 4
.IX Item "Must specify delimiter in $RE{delimited}"
The pattern has no default delimiter.
You need to write: \f(CW\*(C`$RE{delimited}{\-delim=\*(C'\fR\fIX\fR'}> for some character \fIX\fR
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Deepest thanks to the many people who have encouraged and contributed to this
project, especially: Elijah, Jarkko, Tom, Nat, Ed, and Vivek.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
Bound to be plenty.
.PP
For a start, there are many common regexes missing.
Send them in!
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 4
\&         Copyright (c) 2001, Damian Conway. All Rights Reserved.
\&       This module is free software. It may be used, redistributed
\&      and/or modified under the terms of the Perl Artistic License
\&            (see http://www.perl.com/perl/misc/Artistic.html)
.Ve
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 568:" 4
.IX Item "Around line 568:"
You can't have =items (as at line 590) unless the first thing after the =over is an =item
.IP "Around line 732:" 4
.IX Item "Around line 732:"
Unterminated C<...> sequence
