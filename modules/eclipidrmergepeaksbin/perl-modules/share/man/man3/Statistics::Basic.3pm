.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Statistics::Basic 3"
.TH Statistics::Basic 3 "2012-01-23" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Statistics::Basic \- A collection of very basic statistics modules
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Statistics::Basic qw(:all);
.Ve
.PP
These actually return objects, not numbers.  The objects will interpolate as
nicely formated numbers (using Number::Format).  Or the actual number will be
returned when the object is used as a number.
.PP
.Vb 2
\&    my $median = median( 1,2,3 );
\&    my $mean   = mean(  [1,2,3]); # array refs are ok too
\&
\&    my $variance = variance( 1,2,3 );
\&    my $stddev   = stddev(   1,2,3 );
.Ve
.PP
Although passing unblessed numbers and array refs to these functions works, it's
sometimes better to pass vector objects so the objects can reuse calculated
values.
.PP
.Vb 3
\&    my $v1       = $mean\->query_vector;
\&    my $variance = variance( $v1 );
\&    my $stddev   = stddev(   $v1 );
.Ve
.PP
Here, the mean used by the variance and the variance used by the standard
deviation will not need to be recalculated.  Now consider these two
calculations.
.PP
.Vb 2
\&    my $covariance  = covariance(  [1 .. 3], [1 .. 3] );
\&    my $correlation = correlation( [1 .. 3], [1 .. 3] );
.Ve
.PP
The covariance above would need to be recalculated by the correlation when these
functions are called this way.  But, if we instead built vectors first, that
wouldn't happen:
.PP
.Vb 4
\&    # $v1 is defined above
\&    my $v2  = vector(1,2,3);
\&    my $cov = covariance(  $v1, $v2 );
\&    my $cor = correlation( $v1, $v2 );
.Ve
.PP
Now \f(CW$cor\fR can reuse the variance calculated in \f(CW$cov\fR.
.PP
All of the functions above return objects that interpolate or evaluate as a
single string or as a number.  Statistics::Basic::LeastSquareFit and
Statistics::Basic::Mode are different:
.PP
.Vb 2
\&    my $unimodal   = mode(1,2,3,3);
\&    my $multimodal = mode(1,2,3);
\&
\&    print "The modes are: $unimodal and $multimodal.\en";
\&    print "The first is multimodal... " if $unimodal\->is_multimodal;
\&    print "The second is multimodal.\en" if $multimodal\->is_multimodal;
.Ve
.PP
In the first case, \f(CW$unimodal\fR will interpolate as a string \fBand\fR function
correctly as a number.  However, in the second case, trying to use
\&\f(CW$multimodal\fR as a number will \f(CW\*(C`croak\*(C'\fR an error \*(-- it still interpolates fine
though.
.PP
.Vb 1
\&    my $lsf = leastsquarefit($v1, $v2);
.Ve
.PP
This \f(CW$lsf\fR will interpolate fine, showing \f(CW\*(C`LSF( alpha: $alpha, beta: $beta
)\*(C'\fR, but it will \f(CW\*(C`croak\*(C'\fR if you try to use the object as a number.
.PP
.Vb 3
\&    my $v3             = $multimodal\->query;
\&    my ($alpha, $beta) = $lsf\->query;
\&    my $average        = $mean\->query;
.Ve
.PP
All of the objects allow you to explicitly query, if you're not in the mood to
use overload.
.PP
.Vb 5
\&    my @answers = (
\&        $mode\->query,
\&        $median\->query,
\&        $stddev\->query,
\&    );
.Ve
.SH "SHORTCUTS"
.IX Header "SHORTCUTS"
The following shortcut functions can be used in place of calling the module's
\&\f(CW\*(C`new()\*(C'\fR method directly.
.PP
They all take either array refs \fBor\fR lists as arguments, with the exception of
the shortcuts that need two vectors to process (e.g.
Statistics::Basic::Correlation).
.IP "\fB\f(BIvector()\fB\fR" 4
.IX Item "vector()"
Returns a Statistics::Basic::Vector object.
Arguments to \f(CW\*(C`vector()\*(C'\fR can be any of: an array ref, a list of numbers, or a
blessed vector object.  If passed a blessed vector object, vector will just
return the vector passed in.
.IP "\fB\f(BImean()\fB\fR \fB\f(BIaverage()\fB\fR \fB\f(BIavg()\fB\fR" 4
.IX Item "mean() average() avg()"
Returns a Statistics::Basic::Mean object.
You can choose to call \f(CW\*(C`mean()\*(C'\fR as \f(CW\*(C`average()\*(C'\fR or \f(CW\*(C`avg()\*(C'\fR.  Arguments can be
any of: an array ref, a list of numbers, or a blessed vector object.
.IP "\fB\f(BImedian()\fB\fR" 4
.IX Item "median()"
Returns a Statistics::Basic::Median object.
Arguments can be any of: an array ref, a list of numbers, or a blessed vector
object.
.IP "\fB\f(BImode()\fB\fR" 4
.IX Item "mode()"
Returns a Statistics::Basic::Mode object.
Arguments can be any of: an array ref, a list of numbers, or a blessed vector
object.
.IP "\fB\f(BIvariance()\fB\fR \fB\f(BIvar()\fB\fR" 4
.IX Item "variance() var()"
Returns a Statistics::Basic::Variance object.
You can choose to call \f(CW\*(C`variance()\*(C'\fR as \f(CW\*(C`var()\*(C'\fR.  Arguments can be any of: an
array ref, a list of numbers, or a blessed vector object.  If you will also be
calculating the mean of the same list of numbers it's recommended to do this:
.Sp
.Vb 3
\&    my $vec  = vector(1,2,3);
\&    my $mean = mean($vec);
\&    my $var  = variance($vec);
.Ve
.Sp
This would also work:
.Sp
.Vb 2
\&    my $mean = mean(1,2,3);
\&    my $var  = variance($mean\->query_vector);
.Ve
.Sp
This will calculate the same mean twice:
.Sp
.Vb 2
\&    my $mean = mean(1,2,3);
\&    my $var  = variance(1,2,3);
.Ve
.Sp
If you really only need the variance, ignore the above and this is fine:
.Sp
.Vb 1
\&    my $variance = variance(1,2,3,4,5);
.Ve
.IP "\fB\f(BIstddev()\fB\fR" 4
.IX Item "stddev()"
Returns a Statistics::Basic::StdDev object.
Arguments can be any of: an array ref, a list of numbers, or a blessed vector
object.  Pass a vector object to \f(CW\*(C`stddev()\*(C'\fR to avoid recalculating the variance
and mean if applicable (see \f(CW\*(C`variance()\*(C'\fR).
.IP "\fB\f(BIcovariance()\fB\fR \fB\f(BIcov()\fB\fR" 4
.IX Item "covariance() cov()"
Returns a Statistics::Basic::Covariance object.
Arguments to \f(CW\*(C`covariance()\*(C'\fR or \f(CW\*(C`cov()\*(C'\fR must be array ref or vector objects.
There must be precisely two arguments (or none, setting the vectors to two empty
ones), and they must be the same length.
.IP "\fB\f(BIcorrelation()\fB\fR \fB\f(BIcor()\fB\fR \fB\f(BIcorr()\fB\fR" 4
.IX Item "correlation() cor() corr()"
Returns a Statistics::Basic::Correlation object.
Arguments to \f(CW\*(C`correlation()\*(C'\fR or \f(CW\*(C`cor()\*(C'\fR/\f(CW\*(C`corr()\*(C'\fR must be array ref or vector
objects.  There must be precisely two arguments (or none, setting the vectors to
two empty ones), and they must be the same length.
.IP "\fB\f(BIleastsquarefit()\fB\fR \fB\s-1\f(BILSF\s0()\fB\fR \fB\f(BIlsf()\fB\fR" 4
.IX Item "leastsquarefit() LSF() lsf()"
Returns a Statistics::Basic::LeastSquareFit object.
Arguments to \f(CW\*(C`leastsquarefit()\*(C'\fR or \f(CW\*(C`lsf()\*(C'\fR/\f(CW\*(C`LSF()\*(C'\fR must be array ref or
vector objects.  There must be precisely two arguments (or none, setting the
vectors to two empty ones), and they must be the same length.
.IP "\fB\f(BIcomputed()\fB\fR" 4
.IX Item "computed()"
Returns a Statistics::Basic::ComputedVector object.
Argument must be a blessed vector object.  See the section on
\&\*(L"\s-1COMPUTED\s0 \s-1VECTORS\s0\*(R" for more information on this.
.IP "\fB\f(BIhandle_missing_values()\fB\fR \fB\f(BIhandle_missing()\fB\fR" 4
.IX Item "handle_missing_values() handle_missing()"
Returns two Statistics::Basic::ComputedVector objects.
Arguments to this function should be two vector arguments.  See the section on
\&\*(L"\s-1MISSING\s0 \s-1VALUES\s0\*(R" for further information on this function.
.SH "COMPUTED VECTORS"
.IX Header "COMPUTED VECTORS"
Sometimes it will be handy to have a vector computed from another (or at least
that updates based on the first).  Consider the case of outliers:
.PP
.Vb 2
\&    my @a = ( (1,2,3) x 7, 15 );
\&    my @b = ( (1,2,3) x 7 );
\&
\&    my $v1 = vector(@a);
\&    my $v2 = vector(@b);
\&    my $v3 = computed($v1);
\&       $v3\->set_filter(sub {
\&           my $m = mean($v1);
\&           my $s = stddev($v1);
\&
\&           grep { abs($_\-$m) <= $s } @_;
\&       });
.Ve
.PP
This filter sets \f(CW$v3\fR to always be equal to \f(CW$v1\fR such that all the elements
that differ from the mean by more than a standard deviation are removed.  As
such, \f(CW"$v2" eq "$v3"\fR since \f(CW15\fR is clearly an outlier by inspection.
.PP
.Vb 2
\&    print "$v1\en";
\&    print "$v3\en";
.Ve
.PP
\&... prints:
.PP
.Vb 2
\&    [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 15]
\&    [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
.Ve
.SH "MISSING VALUES"
.IX Header "MISSING VALUES"
Something I get asked about quite a lot is, \*(L"can S::B handle missing values?\*(R"
The answer used to be, "that really depends on your data set, use
grep," but I recently decided (5/29/09) that it was time to
just go ahead and add this feature.
.PP
Strictly speaking, the feature was already there.  You simply need to add a
couple filters to your data.  See \f(CW\*(C`t/75_filtered_missings.t\*(C'\fR for the test
example.
.PP
This is what people usually mean when they ask if S::B can \*(L"handle\*(R" missing
data:
.PP
.Vb 4
\&    my $v1 = vector(1,2,3,undef,4);
\&    my $v2 = vector(1,2,3,4, undef);
\&    my $v3 = computed($v1);
\&    my $v4 = computed($v2);
\&
\&    $v3\->set_filter(sub {
\&        my @v = $v2\->query;
\&        map {$_[$_]} grep { defined $v[$_] and defined $_[$_] } 0 .. $#_;
\&    });
\&
\&    $v4\->set_filter(sub {
\&        my @v = $v1\->query;
\&        map {$_[$_]} grep { defined $v[$_] and defined $_[$_] } 0 .. $#_;
\&    });
\&
\&    print "$v1 $v2\en"; # prints: [1, 2, 3, _, 4] [1, 2, 3, 4, _]
\&    print "$v3 $v4\en"; # prints: [1, 2, 3] [1, 2, 3]
.Ve
.PP
But I've made it even simpler.  Since this is such a common request, I have
provided a helper function to build the filters automatically:
.PP
.Vb 2
\&    my $v1 = vector(1,2,3,undef,4);
\&    my $v2 = vector(1,2,3,4, undef);
\&
\&    my ($f1, $f2) = handle_missing_values($v1, $v2);
\&
\&    print "$f1 $f2\en"; # prints: [1, 2, 3] [1, 2, 3]
.Ve
.PP
Note that in practice, you would still manipulate (insert, and shift) \f(CW$v1\fR and
\&\f(CW$v2\fR, \fInot\fR the computed vectors.  But for correlations and the like, you
would use \f(CW$f1\fR and \f(CW$f2\fR.
.PP
.Vb 2
\&    $v1\->insert(5);
\&    $v2\->insert(6);
\&
\&    my $correlation = correlation($f1, $f2);
.Ve
.PP
You can still insert on \f(CW$f1\fR and \f(CW$f2\fR, but it updates the input vector
rather than the computed one (which is just a filter handler).
.SH "REUSE DETAILS"
.IX Header "REUSE DETAILS"
Most of the objects have a variety of query functions that allow you to extract
the objects used within.  Although, the objects are smart enough to prevent
needless duplication.  That is, the following would test would pass:
.PP
.Vb 1
\&    use Statistics::Basic qw(:all);
\&
\&    my $v1 = vector(1,2,3,4,5);
\&    my $v2 = vector($v1);
\&    my $sd = stddev( $v1 );
\&    my $v3 = $sd\->query_vector;
\&    my $m1 = mean( $v1 );
\&    my $m2 = $sd\->query_mean;
\&    my $m3 = Statistics::Basic::Mean\->new( $v1 );
\&    my $v4 = $m3\->query_vector;
\&
\&    use Scalar::Util qw(refaddr);
\&    use Test; plan tests => 5;
\&
\&    ok( refaddr($v1), refaddr($v2) );
\&    ok( refaddr($v2), refaddr($v3) );
\&    ok( refaddr($m1), refaddr($m2) );
\&    ok( refaddr($m2), refaddr($m3) );
\&    ok( refaddr($v3), refaddr($v4) );
\&
\&    # this is t/54_* in the distribution
.Ve
.PP
Also, note that the mean is only calculated once even though we've calculated a
variance and a standard deviation above.
.PP
Suppose you'd like a copy of the Statistics::Basic::Variance object that the
Statistics::Basic::StdDev object is using.  All of the objects within should
be accessible with query functions as follows.
.SH "QUERY FUNCTIONS"
.IX Header "QUERY FUNCTIONS"
.IP "\fB\f(BIquery()\fB\fR" 4
.IX Item "query()"
This method exists in all of the objects.  Statistics::Basic::LeastSquareFit
is the only one that returns two values (alpha and beta) as a list.
Statistics::Basic::Vector returns either the list of elements in the vector,
or reference to that array (depending on the context).  All of the other
\&\f(CW\*(C`query()\*(C'\fR methods return a single number, the number the module purports to
calculate.
.IP "\fB\f(BIquery_mean()\fB\fR" 4
.IX Item "query_mean()"
Returns the Statistics::Basic::Mean object used by
Statistics::Basic::Variance and Statistics::Basic::StdDev.
.IP "\fB\f(BIquery_mean1()\fB\fR" 4
.IX Item "query_mean1()"
Returns the first Statistics::Basic::Mean object used by
Statistics::Basic::Covariance, Statistics::Basic::Correlation and
Statistics::Basic::LeastSquareFit.
.IP "\fB\f(BIquery_mean2()\fB\fR" 4
.IX Item "query_mean2()"
Returns the second Statistics::Basic::Mean object used by
Statistics::Basic::Covariance, and Statistics::Basic::Correlation.
.IP "\fB\f(BIquery_covariance()\fB\fR" 4
.IX Item "query_covariance()"
Returns the Statistics::Basic::Covariance object used by
Statistics::Basic::Correlation and Statistics::Basic::LeastSquareFit.
.IP "\fB\f(BIquery_variance()\fB\fR" 4
.IX Item "query_variance()"
Returns the Statistics::Basic::Variance object used by
Statistics::Basic::StdDev.
.IP "\fB\f(BIquery_variance1()\fB\fR" 4
.IX Item "query_variance1()"
Returns the first Statistics::Basic::Variance object used by
Statistics::Basic::LeastSquareFit.
.IP "\fB\f(BIquery_vector()\fB\fR" 4
.IX Item "query_vector()"
Returns the Statistics::Basic::Vector object used by any of the single vector
modules.
.IP "\fB\f(BIquery_vector1()\fB\fR" 4
.IX Item "query_vector1()"
Returns the first Statistics::Basic::Vector object used by any of the two
vector modules.
.IP "\fB\f(BIquery_vector2()\fB\fR" 4
.IX Item "query_vector2()"
Returns the second Statistics::Basic::Vector object used by any of the two
vector modules.
.IP "\fB\f(BIis_multimodal()\fB\fR" 4
.IX Item "is_multimodal()"
Statistics::Basic::Mode objects sometimes return Statistics::Basic::Vector
objects instead of numbers.  When \f(CW\*(C`is_multimodal()\*(C'\fR is true, the mode is a
vector, not a scalar.
.IP "\fB\f(BIy_given_x()\fB\fR" 4
.IX Item "y_given_x()"
Statistics::Basic::LeastSquareFit is meant for finding a line of best fit.
This function can be used to find the \f(CW\*(C`y\*(C'\fR for a given \f(CW\*(C`x\*(C'\fR based on the
calculated \f(CW$beta\fR (slope) and \f(CW$alpha\fR (y\-offset).
.IP "\fB\f(BIx_given_y()\fB\fR" 4
.IX Item "x_given_y()"
Statistics::Basic::LeastSquareFit is meant for finding a line of best fit.
This function can be used to find the \f(CW\*(C`x\*(C'\fR for a given \f(CW\*(C`y\*(C'\fR based on the
calculated \f(CW$beta\fR (slope) and \f(CW$alpha\fR (y\-offset).
.Sp
This function can produce divide-by-zero errors since it must divide by the
slope to find the \f(CW\*(C`x\*(C'\fR value.  (The slope should rarely be zero though, that's a
vertical line and would represent very odd data points.)
.SH "INSERT and SET FUNCTIONS"
.IX Header "INSERT and SET FUNCTIONS"
These objects are all intended to be useful while processing long columns of
data, like data you'd find in a database.
.IP "\fB\f(BIinsert()\fB\fR" 4
.IX Item "insert()"
Vectors try to stay the same size when they accept new elements, \s-1FIFO\s0 style.
.Sp
.Vb 2
\&    my $v1 = vector(1,2,3); # a 3 touple
\&       $v1\->insert(4); # still a 3 touple
\&
\&    print "$v1\en"; # prints: [2, 3, 4]
\&
\&    $v1\->insert(7); # still a 3 touple
\&    print "$v1\en"; # prints: [3, 4, 7]
.Ve
.Sp
All of the other Statistics::Basic modules have this function too.  The
modules that track two vectors will need two arguments to insert though.
.Sp
.Vb 2
\&    my $mean = mean([1,2,3]);
\&       $mean\->insert(4);
\&
\&    print "mean: $mean\en"; # prints 3 ... (2+3+4)/3
\&
\&    my $correlation = correlation($mean\->query_vector,
\&        $mean\->query_vector\->copy);
\&
\&    print "correlation: $correlation\en"; # 1
\&
\&    $correlation\->insert(3,4);
\&    print "correlation: $correlation\en"; # 0.5
.Ve
.Sp
Also, note that the underlying vectors keep track of recalculating
automatically.
.Sp
.Vb 3
\&    my $v = vector(1,2,3);
\&    my $m = mean($v);
\&    my $s = stddev($v);
.Ve
.Sp
The mean has not been calculated yet.
.Sp
.Vb 1
\&    print "$s; $m\en"; # 0.82; 2
.Ve
.Sp
The mean has been calculated once (even though the Statistics::Basic::StdDev
uses it).
.Sp
.Vb 3
\&    $v\->insert(4); print "$s; $m\en"; 0.82; 3
\&    $m\->insert(5); print "$s; $m\en"; 0.82; 4
\&    $s\->insert(6); print "$s; $m\en"; 0.82; 5
.Ve
.Sp
The mean has been calculated thrice more and only thrice more.
.IP "\fB\f(BIappend()\fB\fR \fB\f(BIginsert()\fB\fR" 4
.IX Item "append() ginsert()"
You can grow the vectors instead of sliding them (\s-1FIFO\s0). For this, use
\&\f(CW\*(C`append()\*(C'\fR (or \f(CW\*(C`ginsert()\*(C'\fR, same thing).
.Sp
.Vb 3
\&    my $v = vector(1,2,3);
\&    my $m = mean($v);
\&    my $s = stddev($v);
\&
\&    $v\->append(4); print "$s; $m\en"; 1.12; 2.5
\&    $m\->append(5); print "$s; $m\en"; 1.41; 3
\&    $s\->append(6); print "$s; $m\en"; 1.71; 1.71
\&
\&    print "$v\en"; # [1, 2, 3, 4, 5, 6]
\&    print "$s\en"; # 1.71
.Ve
.Sp
Of course, with a correlation, or a covariance, it'd look more like this:
.Sp
.Vb 2
\&    my $c = correlation([1,2,3], [3,4,5]);
\&       $c\->append(7,7);
\&
\&    print "c=$c\en"; # c=0.98
.Ve
.IP "\fB\f(BIset_vector()\fB\fR" 4
.IX Item "set_vector()"
This allows you to set the vector to a known state.  It takes either array ref
or vector objects.
.Sp
.Vb 3
\&    my $v1 = vector(1,2,3);
\&    my $v2 = $v1\->copy;
\&       $v2\->set_vector([4,5,6]);
\&
\&    my $m = mean();
\&
\&    $m\->set_vector([1,2,3]);
\&    $m\->set_vector($v2);
\&
\&    my $c = correlation();
\&
\&    $c\->set_vector($v1,$v2);
\&    $c\->set_vector([1,2,3], [4,5,6]);
.Ve
.IP "\fB\f(BIset_size()\fB\fR" 4
.IX Item "set_size()"
This sets the size of the vector.  When the vector is made bigger, the vector is
filled to the new length with leading zeros (i.e., they are the first to be
kicked out after new \f(CW\*(C`insert()\*(C'\fRs.
.Sp
.Vb 2
\&    my $v = vector(1,2,3);
\&       $v\->set_size(7);
\&
\&    print "$v\en"; # [0, 0, 0, 0, 1, 2, 3]
\&
\&    my $m = mean();
\&       $m\->set_size(7);
\&
\&    print "", $m\->query_vector, "\en";
\&     # [0, 0, 0, 0, 0, 0, 0]
\&
\&    my $c = correlation([3],[3]);
\&       $c\->set_size(7);
\&
\&    print "", $c\->query_vector1, "\en";
\&    print "", $c\->query_vector2, "\en";
\&     # [0, 0, 0, 0, 0, 0, 3]
\&     # [0, 0, 0, 0, 0, 0, 3]
.Ve
.SH "OPTIONS"
.IX Header "OPTIONS"
Each of the following options can be specified on package import like this.
.PP
.Vb 2
\&    use Statistics::Basic qw(unbias=0); # start with unbias disabled
\&    use Statistics::Basic qw(unbias=1); # start with unbias enabled
.Ve
.PP
When specified on import, each option has certain defaults.
.PP
.Vb 4
\&    use Statistics::Basic qw(unbias); # start with unbias enabled
\&    use Statistics::Basic qw(nofill); # start with nofill enabled
\&    use Statistics::Basic qw(toler);  # start with toler disabled
\&    use Statistics::Basic qw(ipres);  # start with ipres=2
.Ve
.PP
Additionally, with the exception of \*(L"ignore_env\*(R", they can all be accessed via
package variables of the same name in all upper case.  Example:
.PP
.Vb 1
\&    # code code code
\&
\&    $Statistics::Basic::UNBIAS = 0; # turn UNBIAS off
\&
\&    # code code code
\&
\&    $Statistics::Basic::UNBIAS = 1; # turn it back on
\&
\&    # code code code
\&
\&    { 
\&        local $Statistics::Basic::DEBUG_STATS_B = 1; # debug, this block only
\&    }
.Ve
.PP
Special caveat: \*(L"toler\*(R" can in fact be changed via the package var (e.g.,
\&\f(CW\*(C`$Statistics::Basic::TOLER=0.0001\*(C'\fR).  But, for speed reasons, it must be
defined before any other packages are imported or it will
not actually do anything when changed.
.IP "\fBunbias\fR" 4
.IX Item "unbias"
This module uses the \fBsum(X \- mean(X))/N\fR definition of variance.
.Sp
If you wish to use the \fIunbiased\fR, \fBsum(X\-mean(X)/(N\-1)\fR definition, then set
the \f(CW$Statistics::Basic::UNBIAS\fR true (possibly with
\&\f(CW\*(C`use Statistics::Basic qw(unbias)\*(C'\fR).
.Sp
This can be changed at any time with the package variable or at compile time.
.Sp
This feature was requested by \f(CW\*(C`Robert McGehee <xxxxxxxx@wso.williams.edu>\*(C'\fR.
.Sp
[\s-1NOTE\s0 2008\-11\-06: <http://cpanratings.perl.org/dist/Statistics\-Basic>, this can
also be called "\fBpopulation (n)\fR\*(L" vs \*(R"\fBsample (n\-1)\fR" and is indeed fully
addressed right here!]
.IP "\fBipres\fR" 4
.IX Item "ipres"
\&\f(CW\*(C`ipres\*(C'\fR defaults to 2.  It is passed to Number::Format as the second
argument to \fIformat_number()\fR during string
interpolation (see: overload).
.IP "\fBtoler\fR" 4
.IX Item "toler"
When set, \f(CW$Statistics::Basic::TOLER\fR (which is not enabled by default),
instructs the stats objects to test true when \fIwithin\fR some tolerable range,
pretty much like this:
.Sp
.Vb 3
\&    sub is_equal {
\&        return abs($_[0]\-$_[1])<$Statistics::Basic::TOLER
\&            if defined($Statistics::Basic::TOLER)
\&
\&        return $_[0] == $_[1]
\&    }
.Ve
.Sp
For performance reasons, this must be defined before the import of any other
Statistics::Basic modules or the modules will fail to overload the \f(CW\*(C`==\*(C'\fR
operator.
.Sp
\&\f(CW$Statistics::Basic::TOLER\fR totally disabled:
.Sp
.Vb 1
\&    use Statistics::Basic qw(:all toler);
.Ve
.Sp
\&\f(CW$Statistics::Basic::TOLER\fR disabled, but changeable:
.Sp
.Vb 1
\&    use Statistics::Basic qw(:all toler=0);
\&
\&    $Statistics::Basic::TOLER = 0.000_001;
.Ve
.Sp
You can \fIchange\fR the tolerance at runtime, but it must be set (or unset) at
compile time before the packages load.
.IP "\fBnofill\fR" 4
.IX Item "nofill"
Normally when you set the size of a vector it automatically fills with zeros on
the first-out side of the vector.  You can disable the autofilling with this
option.  It can be changed at any time.
.IP "\fBdebug\fR" 4
.IX Item "debug"
Enable debugging with \f(CW\*(C`use Statistics::Basic qw(debug)\*(C'\fR or disable a specific
level (including \f(CW0\fR to disable) with \f(CW\*(C`use Statistics::Basic qw(debug=2)\*(C'\fR.
.Sp
This is also accessible at runtime using \f(CW$Statistics::Basic::DEBUG_STATS_B\fR and can be
switched on and off at any time.
.IP "\fBignore_env\fR" 4
.IX Item "ignore_env"
Normally the defaults for these options can be changed in the environment of the
program.  Example:
.Sp
.Vb 1
\&    UNBIAS=1 perl ./myprog.pl
.Ve
.Sp
This does the same thing as \f(CW\*(C`$Statistics::Basic::UNBIAS=1\*(C'\fR or
\&\f(CW\*(C`use Statistics::Basic qw(unbias)\*(C'\fR unless you disable the \f(CW%ENV\fR checking with
this option.
.Sp
.Vb 1
\&    use Statistics::Basic qw(ignore_env);
.Ve
.SH "ENVIRONMENT VARIABLES"
.IX Header "ENVIRONMENT VARIABLES"
You can change the defaults (assuming ignore_env is not used)
from your bash prompt.  Example:
.PP
.Vb 1
\&    DEBUG_STATS_B=1 perl ./myprog.pl
.Ve
.ie n .IP "\fB\fB$ENV\fB{\s-1DEBUG_STATS_B\s0}\fR" 4
.el .IP "\fB\f(CB$ENV\fB{\s-1DEBUG_STATS_B\s0}\fR" 4
.IX Item "$ENV{DEBUG_STATS_B}"
Sets the default value of \*(L"debug\*(R".
.ie n .IP "\fB\fB$ENV\fB{\s-1UNBIAS\s0}\fR" 4
.el .IP "\fB\f(CB$ENV\fB{\s-1UNBIAS\s0}\fR" 4
.IX Item "$ENV{UNBIAS}"
Sets the default value of \*(L"unbias\*(R".
.ie n .IP "\fB\fB$ENV\fB{\s-1NOFILL\s0}\fR" 4
.el .IP "\fB\f(CB$ENV\fB{\s-1NOFILL\s0}\fR" 4
.IX Item "$ENV{NOFILL}"
Sets the default value of \*(L"nofill\*(R".
.ie n .IP "\fB\fB$ENV\fB{\s-1IPRES\s0}\fR" 4
.el .IP "\fB\f(CB$ENV\fB{\s-1IPRES\s0}\fR" 4
.IX Item "$ENV{IPRES}"
Sets the default value of \*(L"ipres\*(R".
.ie n .IP "\fB\fB$ENV\fB{\s-1TOLER\s0}\fR" 4
.el .IP "\fB\f(CB$ENV\fB{\s-1TOLER\s0}\fR" 4
.IX Item "$ENV{TOLER}"
Sets the default value of \*(L"toler\*(R".
.SH "OVERLOADS"
.IX Header "OVERLOADS"
All of the objects are true in numeric context.  All of the objects print useful
strings when evaluated as a string.  Most of the objects evaluate usefully as
numbers, although Statistics::Basic::Vector objects,
Statistics::Basic::ComputedVector objects, and
Statistics::Basic::LeastSquareFit objects do not \*(-- they instead raise an
error.
.SH "Author's note on Statistics::Descriptive"
.IX Header "Author's note on Statistics::Descriptive"
I've been asked a couple times now why I don't link to
Statistics::Descriptive in my see also section.  As a rule, I only link to
packages there that I think are related or that I actually used in the package
construction.  I've never personally used Descriptive, but it surely seems to do
quite a lot more.  In a sense, this package really doesn't do statistics, not
like a scientist would think about it anyway.  So I always figured people could
find their own way to Descriptive anyway.
.PP
The one thing this package does do, that I don't think Descriptive does (correct
me if I'm wrong) is time difference computations.  If there are say, 200 things
in the mean object, then after inserting (using this package) there'll still be
200 things, allowing the computation of a moving average, moving stddev, moving
correlation, etc.  You might argue that this is rarely needed, but it is really
the only time I need to compute these things.
.PP
.Vb 4
\&  while( $data = $fetch_sth\->fetchrow_arrayref ) {
\&      $mean\->insert($data);
\&      $moving_avg_sth\->execute(0 + $mean);
\&  }
.Ve
.PP
Since I opened the topic I'd also like to mention that I find this package
easier to use.  That is a matter of taste and since I wrote this, you might say
I'm a little biased.  Your mileage may vary.
.SH "AUTHOR"
.IX Header "AUTHOR"
Paul Miller \f(CW\*(C`<jettero@cpan.org>\*(C'\fR
.PP
I am using this software in my own projects...  If you find bugs, please
please please let me know. :) Actually, let me know if you find it handy at
all.  Half the fun of releasing this stuff is knowing that people use it.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2012 Paul Miller \*(-- Licensed under the \s-1LGPL\s0 version 2.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), Number::Format, overload,
Statistics::Basic::Vector,
Statistics::Basic::ComputedVector,
Statistics::Basic::_OneVectorBase,
Statistics::Basic::Mean,
Statistics::Basic::Median,
Statistics::Basic::Mode,
Statistics::Basic::Variance,
Statistics::Basic::StdDev,
Statistics::Basic::_TwoVectorBase,
Statistics::Basic::Correlation,
Statistics::Basic::Covariance,
Statistics::Basic::LeastSquareFit
